import streamlit as st
from oracle_engine import OracleEngine
import pandas as pd
import math # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô floor ‡πÉ‡∏ô Fibonacci

# --- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÅ‡∏•‡∏∞ CSS ---
st.set_page_config(page_title="üîÆ Oracle AI", layout="centered")

st.markdown("""
    <style>
    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏´‡∏•‡∏±‡∏Å */
    .custom-title {
        font-family: 'Georgia', serif;
        font-size: 3rem;
        text-align: center;
        color: #FFD700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        margin-bottom: 0.5rem;
        font-weight: bold;
    }
    /* ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏≠‡∏á‡∏Ñ‡πå‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö Streamlit */
    .stApp > header {
        display: none; /* ‡∏ã‡πà‡∏≠‡∏ô Header ‡∏Ç‡∏≠‡∏á Streamlit */
    }
    .stApp {
        padding-top: 1rem; /* ‡∏•‡∏î padding ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ */
        padding-bottom: 1rem; /* ‡∏•‡∏î padding ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ */
    }
    .st-emotion-cache-z5fcl4 { /* Target specific class for block container */
        padding-top: 1rem;
        padding-bottom: 1rem;
    }

    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Label ‡∏Ç‡∏≠‡∏á st.number_input, st.selectbox, st.text_input */
    .stNumberInput > label, .stSelectbox > label, .stTextInput > label {
        font-size: 0.95rem;
        font-weight: bold;
        margin-bottom: 0.1rem; /* ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á label */
    }
    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á input ‡∏Ç‡∏≠‡∏á st.number_input */
    .stNumberInput div[data-baseweb="input"] input {
        font-size: 0.95rem;
    }
    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ú‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á */
    .history-display {
        font-size: 1.2rem;
        word-wrap: break-word;
        background-color: #262730; /* ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤‡πÄ‡∏Ç‡πâ‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏ò‡∏µ‡∏°‡∏°‡∏∑‡∏î */
        padding: 10px;
        border-radius: 5px;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
        min-height: 40px;
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }
    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠ h4 ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö */
    h4 {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        font-size: 1.25rem;
    }
    /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ (‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô) */
    .prediction-text {
        font-size: 2rem;
        font-weight: bold;
        color: #4CAF50; /* ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß */
        text-align: center;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
    }
    /* ‡∏•‡∏î margin ‡∏Ç‡∏≠‡∏á‡∏õ‡∏∏‡πà‡∏° */
    div.stButton > button {
        margin-top: 0.2rem;
        margin-bottom: 0.2rem;
    }
    /* ‡∏•‡∏î margin ‡∏Ç‡∏≠‡∏á st.columns */
    div.stColumns > div {
        padding-top: 0.1rem;
        padding-bottom: 0.1rem;
    }
    /* ‡∏•‡∏î margin ‡∏Ç‡∏≠‡∏á info/warning boxes */
    .stAlert {
        margin-top: 0.5rem !important;
        margin-bottom: 0.5rem !important;
    }
    </style>
""", unsafe_allow_html=True)

# ‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏±‡∏ß‡∏Ç‡∏≠‡∏á‡πÅ‡∏≠‡∏õ
st.markdown('<div class="custom-title">üîÆ Oracle AI</div>', unsafe_allow_html=True)

# --- ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Session State ---
if "history" not in st.session_state:
    st.session_state.history = []
if "money_balance" not in st.session_state:
    st.session_state.money_balance = 1000.0
if "bet_amount" not in st.session_state:
    st.session_state.bet_amount = 100.0 # Initial default bet amount
if "bet_log" not in st.session_state:
    st.session_state.bet_log = []
if "oracle_engine" not in st.session_state:
    st.session_state.oracle_engine = OracleEngine()

# --- Session State ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏á‡∏¥‡∏ô ---
if "money_management_system" not in st.session_state:
    st.session_state.money_management_system = "Fixed Bet" # Default system

# Martingale State
if "martingale_current_step" not in st.session_state:
    st.session_state.martingale_current_step = 0 # 0 = starting bet
if "martingale_base_bet" not in st.session_state:
    st.session_state.martingale_base_bet = 100.0 # Default starting bet

# Fibonacci State
if "fibonacci_sequence" not in st.session_state:
    # Standard Fibonacci sequence (indexed from 0)
    st.session_state.fibonacci_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]
if "fibonacci_current_index" not in st.session_state:
    st.session_state.fibonacci_current_index = 1 # Start with 1 unit (index 1)
if "fibonacci_unit_bet" not in st.session_state:
    st.session_state.fibonacci_unit_bet = 100.0 # Default unit bet

# Labouchere State
if "labouchere_original_sequence" not in st.session_state:
    st.session_state.labouchere_original_sequence = [1.0, 2.0, 3.0, 4.0] # Default sequence
if "labouchere_current_sequence" not in st.session_state:
    st.session_state.labouchere_current_sequence = st.session_state.labouchere_original_sequence.copy()
if "labouchere_unit_bet" not in st.session_state:
    st.session_state.labouchere_unit_bet = 100.0 # Default unit bet

# --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ---
def calculate_next_bet():
    system = st.session_state.money_management_system
    
    if system == "Fixed Bet":
        return st.session_state.bet_amount
    
    elif system == "Martingale":
        # Calculate current bet based on step and base bet
        current_bet_multiplier = st.session_state.martingale_multiplier ** st.session_state.martingale_current_step
        next_bet = st.session_state.martingale_base_bet * current_bet_multiplier
        
        # Check against Max Martingale Steps
        if st.session_state.martingale_current_step >= st.session_state.martingale_max_steps:
            st.warning(f"Martingale ‡∏ñ‡∏∂‡∏á‡πÑ‡∏°‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ({st.session_state.martingale_max_steps}) ‡πÅ‡∏•‡πâ‡∏ß! ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏ê‡∏≤‡∏ô.")
            return st.session_state.martingale_base_bet # ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ä‡πâ base bet ‡∏´‡∏≤‡∏Å‡∏ñ‡∏∂‡∏á‡πÑ‡∏°‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î

        return next_bet

    elif system == "Fibonacci":
        fib_seq = st.session_state.fibonacci_sequence
        current_idx = st.session_state.fibonacci_current_index
        max_steps = st.session_state.fibonacci_max_steps_input # ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å input

        # Ensure index is within bounds of defined sequence
        if current_idx >= len(fib_seq) or current_idx > max_steps:
            st.warning(f"Fibonacci ‡∏ñ‡∏∂‡∏á‡πÑ‡∏°‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ({max_steps}) ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß! ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢.")
            return st.session_state.fibonacci_unit_bet # ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ä‡πâ unit bet

        next_bet = fib_seq[current_idx] * st.session_state.fibonacci_unit_bet
        return next_bet

    elif system == "Labouchere":
        current_seq = st.session_state.labouchere_current_sequence
        unit_bet = st.session_state.labouchere_unit_bet

        if not current_seq: # ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡∏ä‡∏ô‡∏∞‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß
            st.success("Labouchere: ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏£‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß! ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏•‡∏≥‡∏î‡∏±‡∏ö.")
            st.session_state.labouchere_current_sequence = st.session_state.labouchere_original_sequence.copy()
            if not st.session_state.labouchere_current_sequence: # If original sequence is also empty, fallback
                return unit_bet # Fallback if original sequence is empty
            current_seq = st.session_state.labouchere_current_sequence # Update current_seq after reset

        if len(current_seq) == 1:
            next_bet = current_seq[0] * unit_bet
        else:
            next_bet = (current_seq[0] + current_seq[-1]) * unit_bet
        
        return next_bet
    
    return st.session_state.bet_amount # Fallback

# --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Callback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô ---
def add_to_history(result):
    st.session_state.history.append(result)

def remove_last_from_history():
    if st.session_state.history:
        st.session_state.history.pop()
    # Reset money management states on history removal (optional, but good for consistency)
    reset_money_management_state_on_undo()

def reset_all_history():
    st.session_state.history = []
    st.session_state.money_balance = 1000.0
    st.session_state.bet_log = []
    st.session_state.oracle_engine = OracleEngine() # ‡∏™‡∏£‡πâ‡∏≤‡∏á Engine ‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï Memory Logic
    reset_money_management_state() # ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

def reset_money_management_state():
    # Martingale
    st.session_state.martingale_current_step = 0
    # Fibonacci
    st.session_state.fibonacci_current_index = 1
    # Labouchere
    st.session_state.labouchere_current_sequence = st.session_state.labouchere_original_sequence.copy()

def reset_money_management_state_on_undo():
    # This function would be more complex to truly "undo" a step in Martingale/Fibonacci/Labouchere
    # For simplicity, we just reset the current system's state to base.
    # A true undo would require storing the state *before* each bet.
    if st.session_state.money_management_system == "Martingale":
        st.session_state.martingale_current_step = 0
    elif st.session_state.money_management_system == "Fibonacci":
        st.session_state.fibonacci_current_index = 1
    elif st.session_state.money_management_system == "Labouchere":
        st.session_state.labouchere_current_sequence = st.session_state.labouchere_original_sequence.copy()


def record_bet_result(predicted_side, actual_result):
    bet_amt_for_log = st.session_state.bet_amount_calculated # Use the calculated bet amount for the log
    win_loss = 0.0
    outcome = "Miss"

    current_system = st.session_state.money_management_system

    # Update money management state based on actual result
    if current_system == "Martingale":
        if predicted_side == actual_result: # Win
            st.session_state.martingale_current_step = 0 # Reset step
        else: # Loss
            st.session_state.martingale_current_step += 1
            # Ensure not to exceed max steps
            if st.session_state.martingale_current_step > st.session_state.martingale_max_steps:
                st.session_state.martingale_current_step = st.session_state.martingale_max_steps

    elif current_system == "Fibonacci":
        fib_seq = st.session_state.fibonacci_sequence
        current_idx = st.session_state.fibonacci_current_index
        
        if predicted_side == actual_result: # Win
            # Go back two steps, but not below index 1 (0 is not used for betting)
            st.session_state.fibonacci_current_index = max(1, current_idx - 2)
        else: # Loss
            # Move to next step
            st.session_state.fibonacci_current_index += 1
            # Ensure not to exceed max steps or sequence length
            max_steps = st.session_state.fibonacci_max_steps_input
            if st.session_state.fibonacci_current_index >= len(fib_seq) or st.session_state.fibonacci_current_index > max_steps:
                st.session_state.fibonacci_current_index = max_steps # Cap at max_steps or end of defined sequence

    elif current_system == "Labouchere":
        current_seq = st.session_state.labouchere_current_sequence
        
        # Only modify sequence if it's not empty before this bet
        if current_seq:
            if predicted_side == actual_result: # Win
                if len(current_seq) <= 2: # If 1 or 2 numbers left, sequence becomes empty
                    st.session_state.labouchere_current_sequence = []
                else:
                    # Remove first and last element
                    st.session_state.labouchere_current_sequence = current_seq[1:-1]
            else: # Loss
                # Add the bet amount (converted to unit) to the end of the sequence
                # bet_amt_for_log / st.session_state.labouchere_unit_bet gives the 'unit' value
                if st.session_state.labouchere_unit_bet > 0:
                    st.session_state.labouchere_current_sequence.append(bet_amt_for_log / st.session_state.labouchere_unit_bet)
                else: # Prevent division by zero, just add a 1 unit
                    st.session_state.labouchere_current_sequence.append(1.0)
        else: # Sequence was already empty (completed last round)
            st.session_state.labouchere_current_sequence = st.session_state.labouchere_original_sequence.copy() # Reset for new round

    # --- Calculation of Win/Loss for actual money balance ---
    # This part remains the same as it's about actual money change
    if predicted_side in ['P', 'B', 'T']: # Only if the system *intended* to bet
        if predicted_side == actual_result:
            outcome = "Hit"
            if actual_result == 'P':
                win_loss = bet_amt_for_log
            elif actual_result == 'B':
                win_loss = bet_amt_for_log * 0.95 # Banker deduction
            elif actual_result == 'T':
                win_loss = bet_amt_for_log * 8.0 # Tie payout
            st.session_state.money_balance += win_loss
        else: # Loss
            win_loss = -bet_amt_for_log
            st.session_state.money_balance -= bet_amt_for_log
    else: # If predicted_side was '?' or 'Avoid' - no actual bet was placed
        win_loss = 0.0
        outcome = "Avoided"

    st.session_state.bet_log.append({
        "System": current_system,
        "Bet Amount": f"{bet_amt_for_log:.2f}",
        "Predict": predicted_side,
        "Actual": actual_result,
        "Win/Loss": f"{win_loss:+.2f}",
        "Balance": f"{st.session_state.money_balance:.2f}",
        "Outcome": outcome
    })
    
    st.session_state.history.append(actual_result) # Add actual result to history for engine

# ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Engine
engine = st.session_state.oracle_engine
engine.history = st.session_state.history.copy()

# --- ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô ---
st.session_state.money_balance = st.number_input(
    "üí∞ ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô:",
    min_value=0.0, # ‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0 ‡πÑ‡∏î‡πâ
    value=st.session_state.money_balance,
    step=100.0,
    format="%.2f",
    help="‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì"
)

# --- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏á‡∏¥‡∏ô ---
st.session_state.money_management_system = st.selectbox(
    "üìä ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏á‡∏¥‡∏ô:",
    ("Fixed Bet", "Martingale", "Fibonacci", "Labouchere"),
    key="select_money_system"
)

# UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Fixed Bet
if st.session_state.money_management_system == "Fixed Bet":
    st.session_state.bet_amount = st.number_input(
        "üí∏ ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏ï‡πà‡∏≠‡∏ï‡∏≤ (Fixed Bet):",
        min_value=1.0,
        value=st.session_state.bet_amount,
        step=10.0,
        format="%.2f",
        help="‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏≤"
    )

# UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Martingale
elif st.session_state.money_management_system == "Martingale":
    st.session_state.martingale_base_bet = st.number_input(
        "üí∞ ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Martingale:",
        min_value=1.0,
        value=st.session_state.martingale_base_bet,
        step=10.0,
        format="%.2f",
        help="‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö Martingale"
    )
    st.session_state.martingale_multiplier = st.number_input(
        "‚úñÔ∏è ‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì Martingale (‡πÄ‡∏ä‡πà‡∏ô 2.0):",
        min_value=1.1, # ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 1
        value=2.0,
        step=0.1,
        format="%.1f",
        help="‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏û‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö Martingale"
    )
    st.session_state.martingale_max_steps = st.number_input(
        "ü™ú ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î Martingale (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á):",
        min_value=1,
        value=5,
        step=1,
        format="%d",
        help="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏û‡πâ"
    )
    st.info(f"Martingale: ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà {st.session_state.martingale_current_step}")

# UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Fibonacci
elif st.session_state.money_management_system == "Fibonacci":
    st.session_state.fibonacci_unit_bet = st.number_input(
        "üí∏ ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢ Fibonacci:",
        min_value=1.0,
        value=st.session_state.fibonacci_unit_bet,
        step=10.0,
        format="%.2f",
        help="1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö Fibonacci ‡∏à‡∏∞‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà"
    )
    st.session_state.fibonacci_max_steps_input = st.number_input(
        "ü™ú ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î Fibonacci (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á):",
        min_value=1,
        value=len(st.session_state.fibonacci_sequence) - 1, # Default to actual length of sequence
        step=1,
        format="%d",
        help="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏ö‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö Fibonacci"
    )
    st.info(f"Fibonacci: ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà {st.session_state.fibonacci_current_index} (‡∏Ñ‡πà‡∏≤ {st.session_state.fibonacci_sequence[st.session_state.fibonacci_current_index]})")

# UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Labouchere
elif st.session_state.money_management_system == "Labouchere":
    original_seq_str = ",".join([str(s) for s in st.session_state.labouchere_original_sequence])
    
    new_original_seq_str = st.text_input(
        "üî¢ ‡∏•‡∏≥‡∏î‡∏±‡∏ö Labouchere (‡∏Ñ‡∏±‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢ , ‡πÄ‡∏ä‡πà‡∏ô 1,2,3,4):",
        value=original_seq_str,
        help="‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á Labouchere"
    )
    # Parse the input string to update original_sequence
    try:
        parsed_seq = [float(x.strip()) for x in new_original_seq_str.split(',') if x.strip()]
        if parsed_seq: # Only update if parsed successfully and not empty
            if st.session_state.labouchere_original_sequence != parsed_seq:
                st.session_state.labouchere_original_sequence = parsed_seq
                st.session_state.labouchere_current_sequence = parsed_seq.copy() # Reset current sequence
        elif not parsed_seq and st.session_state.labouchere_original_sequence: # User cleared input
             st.session_state.labouchere_original_sequence = []
             st.session_state.labouchere_current_sequence = []
    except ValueError:
        st.error("Invalid Labouchere sequence format. Please use numbers separated by commas.")
        
    st.session_state.labouchere_unit_bet = st.number_input(
        "üí∏ ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢ Labouchere:",
        min_value=1.0,
        value=st.session_state.labouchere_unit_bet,
        step=10.0,
        format="%.2f",
        help="1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö Labouchere ‡∏à‡∏∞‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà"
    )
    st.info(f"Labouchere: ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: {', '.join([f'{x:.1f}' for x in st.session_state.labouchere_current_sequence]) if st.session_state.labouchere_current_sequence else '‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤ (‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!)'}")


# ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
st.session_state.bet_amount_calculated = calculate_next_bet()
st.info(f"**‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏ï‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ:** {st.session_state.bet_amount_calculated:.2f} ‡∏ö‡∏≤‡∏ó")


if len(engine.history) < 20:
    st.warning(f"‚ö†Ô∏è ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 20 ‡∏ï‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏î‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥\n(‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ **{len(engine.history)}** ‡∏ï‡∏≤)")

# --- ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå ---
st.markdown("#### üîÆ ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ï‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ:")
prediction_data = None
next_pred_side = '?'
conf = 0

if len(engine.history) >= 20:
    prediction_data = engine.predict_next()

    if isinstance(prediction_data, dict) and 'prediction' in prediction_data and 'recommendation' in prediction_data:
        next_pred_side = prediction_data['prediction']
        conf = engine.confidence_score()

        emoji_map = {'P': 'üîµ Player', 'B': 'üî¥ Banker', 'T': 'üü¢ Tie', '?': '‚Äî ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥'}

        st.markdown(f'<div class="prediction-text">{emoji_map.get(next_pred_side, "?")} (Confidence: {conf}%)</div>', unsafe_allow_html=True)
        st.markdown(f"**üìç ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á:** {prediction_data['risk']}")
        st.markdown(f"**üßæ ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:** **{prediction_data['recommendation']}**")

        with st.expander("üß¨ Developer View"):
            st.write(prediction_data['developer_view'])
    else:
        st.error("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏à‡∏≤‡∏Å OracleEngine. ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö 'oracle_engine.py'")
        st.markdown("‚Äî (‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏î‡πâ)")
else:
    st.markdown("‚Äî (‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö)")

# --- ‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå + ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ + ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° ---
st.markdown("#### üìù ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:")
history_emojis = engine.get_history_emojis()

if history_emojis:
    display_history_str = " ".join(history_emojis[-30:])
    if len(history_emojis) > 30:
        display_history_str = "... " + display_history_str
    st.markdown(f"<p class='history-display'>{display_history_str}</p>", unsafe_allow_html=True)
else:
    st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥")

col_p_b_t = st.columns(3)

if prediction_data and isinstance(prediction_data, dict) and 'recommendation' in prediction_data:
    if prediction_data['recommendation'] == "Play ‚úÖ":
        with col_p_b_t[0]:
            if st.button(f"üîµ P", key="result_P_play", use_container_width=True):
                record_bet_result(prediction_data['prediction'], 'P')
                st.rerun()
        with col_p_b_t[1]:
            if st.button(f"üî¥ B", key="result_B_play", use_container_width=True):
                record_bet_result(prediction_data['prediction'], 'B')
                st.rerun()
        with col_p_b_t[2]:
            if st.button(f"üü¢ T", key="result_T_play", use_container_width=True):
                record_bet_result(prediction_data['prediction'], 'T')
                st.rerun()
    elif prediction_data['recommendation'] == "Avoid ‚ùå":
        with col_p_b_t[0]:
            if st.button(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: üîµ P", key="no_bet_P", use_container_width=True):
                record_bet_result('?', 'P')
                st.rerun()
        with col_p_b_t[1]:
            if st.button(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: üî¥ B", key="no_bet_B", use_container_width=True):
                record_bet_result('?', 'B')
                st.rerun()
        with col_p_b_t[2]:
            if st.button(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: üü¢ T", key="no_bet_T", use_container_width=True):
                record_bet_result('?', 'T')
                st.rerun()
else:
    with col_p_b_t[0]:
        if st.button(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: üîµ P", key="init_P", use_container_width=True):
            record_bet_result('?', 'P')
            st.rerun()
    with col_p_b_t[1]:
        if st.button(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: üî¥ B", key="init_B", use_container_width=True):
            record_bet_result('?', 'B')
            st.rerun()
    with col_p_b_t[2]:
        if st.button(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: üü¢ T", key="init_T", use_container_width=True):
            record_bet_result('?', 'T')
            st.rerun()

col_hist1, col_hist2 = st.columns(2)
with col_hist1:
    if st.button("‚Ü©Ô∏è ‡∏•‡∏ö‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î", key="delLastHist", use_container_width=True, on_click=remove_last_from_history):
        st.rerun()
with col_hist2:
    if st.button("üßπ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î", key="resetAllHist", use_container_width=True, on_click=reset_all_history):
        st.rerun()

# --- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô (Bet Log) ---
st.markdown("### üìä ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô")
if st.session_state.bet_log:
    df_log = pd.DataFrame(st.session_state.bet_log)
    st.dataframe(df_log, use_container_width=True, hide_index=True)
else:
    st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ")

# --- ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏¥‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ---
st.caption("‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå Oracle AI ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏∏‡∏ì")
